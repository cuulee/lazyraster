---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# lazyraster

The goal of lazyraster is to get raster data on demand at the right resolution. 

We can specify the exact dimensions of the output raster, and by default a reasonable
guess at the number of pixels required to fill the current device will be used. 

We can specify a variety of resampling algorithms (nearest neighbour is the default) and the resampling can be applied to reduce or increase the resolution. 

This uses a standard internal functionality of GDAL, the [RasterIO function of the GDALRasterBand](http://www.gdal.org/classGDALRasterBand.html#a30786c81246455321e96d73047b8edf1). This is used in a lot of different software, and is obviously pretty robust and well tested by the GDAL community, but I only really have experience with one product (commercial, now defunct) that used it extensively for live interactive visualization and data streaming. I haven't found any problems with it at all using it in R, but the suport for it is very minimal. You can access it indirectly using `rgdal::readGDAL` and its underlying functions, as the `raster` package does.  

## Limitations

We can't utilize the RasterIO level-of-detail functionality for non-GDAL sources. 

We can't yet easily specify a crop, and level-of-detail - but that's not hard - mostly I need to figure out what set of functions should exist for this. 

We can only read the first band. 

The only really useable output is a raster layer. You cannot specify easily that the return is at native resolution (just use raster for that). 

We can't control the details of the data type. 

The projection string is not coming through properly. 

The plot-size logic should work on the current "usr" world coordinates, not the size of the device (if it's different). 


## Example


This is not a huge file, but is easily accessible and demonstrates the idea. 


```{r GeoTIFF}
sstfile <- system.file("extdata/sst.tif", package = "vapour")
library(lazyraster)
lazy <- lazyraster(sstfile)
lazy ## stay lazy

## be only so lazy
as_raster(lazy, dim = c(12, 24))

## note how we actually resample up because this data is not very large
as_raster(lazy)

## what do we get if we set up a bitmap device
tf <- tempfile(fileext = "png")
png(tf, height = 50, width = 40)
as_raster(lazy)
#plot(as_raster(lazy))
dev.off()
unlink(tf)
```

Does it work on really big files? 

(This can't work on your computer probably, but try it on your favourite big file). 

```{r raadtools}
library(raadtools)
f <- raadtools::topofile("gebco_14")
lazyraster(f)
library(raster)
op <- par(mar = rep(0, 4))
system.time({
  r <- lazyraster(f)
plot(r, col = grey(seq(0, 1, length = 100)), axes = FALSE, xlab = "", ylab = "", asp = "", legend = FALSE)
})
par(op)
```

An earlier example, should be made a WMS-specific function ...

Make a TMS source and read at the desired resolution. 

More here: http://rpubs.com/cyclemumner/358029



```{r example}
library(lazyraster)
gibs_xml <- function(date, level = 3) {
  date <- format(date, "%Y-%m-%d")
sprintf('<GDAL_WMS>
         <Service name="TMS">
         <ServerUrl>
         https://gibs.earthdata.nasa.gov/wmts/epsg3413/best/MODIS_Terra_CorrectedReflectance_TrueColor/default/%s/250m/${z}/${y}/${x}.jpg</ServerUrl>
         </Service>
         <DataWindow>
         <UpperLeftX>-4194304</UpperLeftX>
         <UpperLeftY>4194304</UpperLeftY>
         <LowerRightX>4194304</LowerRightX>
         <LowerRightY>-4194304</LowerRightY>
         <TileLevel>%i</TileLevel>
         <TileCountX>2</TileCountX>
         <TileCountY>2</TileCountY>
         <YOrigin>top</YOrigin>
         </DataWindow>
         <Projection>EPSG:3413</Projection>
         <BlockSizeX>512</BlockSizeX>
         <BlockSizeY>512</BlockSizeY>
         <BandsCount>3</BandsCount>
         </GDAL_WMS>
         ', date, level)
}

s <- gibs_xml(Sys.Date()-10)
r <- raster::raster(s)
r2 <- collect(r, nrows= 150, ncols = 150)
library(raster)
plot(r2, col = head(palr::sstPal(64), 45))
```
